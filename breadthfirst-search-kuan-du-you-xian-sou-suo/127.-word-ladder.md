# 127. Word Ladder

[https://leetcode.com/problems/word-ladder/submissions/](https://leetcode.com/problems/word-ladder/submissions/)\
\
BFS in implicit Graph, 需要自己建立定点，边的概念。Find Neighbor\


```java
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> dictionary = new HashSet<>();
        for(String word : wordList){
            dictionary.add(word);
        }

        dictionary.add(beginWord);
      

        Queue<String> queue = new LinkedList<String>();
        queue.offer(beginWord);
        HashMap<String, Integer> distance = new HashMap<>();
        distance.put(beginWord, 1);
        
        while(!queue.isEmpty()){
            String node = queue.poll();
            int length = distance.get(node);
             if(node.equals(endWord)){
                return length;
            }
            for(String neighbor : findNeighbors(node, dictionary)){
                if(distance.containsKey(neighbor)){
                    continue;
                }
                distance.put(neighbor, length + 1);
                queue.offer(neighbor);
            }
        }
        return 0;
    }

    public ArrayList<String>  findNeighbors(String node, Set<String> dictionary){
        ArrayList<String> nextNodes = new ArrayList<>();
        for(int i = 0; i < node.length(); i++){
           for(char c = 'a'; c <= 'z'; c++){
               if(node.charAt(i) == c){
                   continue;
               }
               String newNode = replace(node, i, c); 
               if(dictionary.contains(newNode)){
                    nextNodes.add(newNode);
               }
           }
        }
        return nextNodes;
    }

    public String replace(String node, int index, char c){
        char[] chars = node.toCharArray();
        chars[index] = c;
        return new String(chars);
    }
}
```

[https://www.youtube.com/watch?v=q1f-3Exu6GM\&t=3s](https://www.youtube.com/watch?v=q1f-3Exu6GM\&t=3s)

```java
class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> dictionary = new HashSet<>();
        for(String word : wordList){
            dictionary.add(word);
        }
        
        int step = 0;
        Queue<String> queue = new LinkedList<>();
        queue.offer(beginWord);
        
        while(!queue.isEmpty()){
            
            step++;
            int size = queue.size();
            for(int i = 0; i < size; i++){
                String word = queue.poll();
                if(word.equals(endWord)){
                    return step;
                }
                StringBuilder sb = new StringBuilder(word);
                for(int j = 0; j < word.length(); j++){
                    for(char c = 'a'; c <= 'z'; c++){
                        if(c == word.charAt(j)){
                            continue;
                        }
                        sb.setCharAt(j, c);
                        if(dictionary.contains(sb.toString())){
                            queue.offer(sb.toString());
                            dictionary.remove(sb.toString());
                        }
                    }
                    sb.setCharAt(j, word.charAt(j));
                }
            }
        }
        return 0;
    }
}
```
